<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
  <channel>
    <title>最新提交：编程</title>
    <link>https://www.reddit.com/r/programming/new</link>
    <description>计算机编程</description>
    <lastBuildDate>Mon, 12 May 2025 03:21:45 GMT</lastBuildDate>
    <item>
      <title>libcello-一个现代化C的很酷的项目</title>
      <link>https://www.reddit.com/r/programming/comments/1kkhxcp/libcello_a_cool_project_to_modernize_c/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  不是我的。我一直想对此做些事情，但是它从未与个人或专业匹配。  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/esdraelon      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kkhxcp/libcello_a_cool_project_to_modernize_c/</guid>
      <pubDate>Mon, 12 May 2025 02:37:33 GMT</pubDate>
    </item>
    <item>
      <title>Rust Devs认为我们是绝望的。让我们证明它们是错误的（使用C ++内存泄漏）！</title>
      <link>https://www.reddit.com/r/programming/comments/1kkhgtq/rust_devs_think_were_hopeless_lets_prove_them/</link>
      <description><![CDATA[＆＃32;提交由＆＃32;态href =“ https://www.babaei.net/blog/rust-devs-think-we-we-are-are-hopeless-rebless-lesles-prove-them-withem-with-with-with-with-with-with-cpp-memory-leaks/#a-_crtdump-mememoryleaks-dump-mememoryleaks-1-  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kkhgtq/rust_devs_think_were_hopeless_lets_prove_them/</guid>
      <pubDate>Mon, 12 May 2025 02:12:16 GMT</pubDate>
    </item>
    <item>
      <title>第40天：您在JavaScript中使用`json.stringify（）吗？</title>
      <link>https://www.reddit.com/r/programming/comments/1kkha8d/day_40_are_you_underusing_jsonstringify_in/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/myssiriouseye8494     [link]        [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kkha8d/day_40_are_you_underusing_jsonstringify_in/</guid>
      <pubDate>Mon, 12 May 2025 02:02:25 GMT</pubDate>
    </item>
    <item>
      <title>S4F3-C0D3S：恢复代码管理器</title>
      <link>https://www.reddit.com/r/programming/comments/1kkfy14/s4f3c0d3s_recovery_codes_manager/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;     s4f3-c0d3s 是一个安全的，加密的，离线的，无云的，免费的，免费的，开放式的恢复代码（2FA）管理器，没有订阅，没有数据收集，没有数据收集，交叉平台，和Port-Platform和Port-P&gt;       s4f3-c0d3s 是源于对储存恢复代码（2FA）的真实和个人需求诞生的。很多时候，我们最终将这些敏感的信息保存在记事本，屏幕截图，照片或未受保护的文件中，这使我们的数字安全处于风险状态。  尽管密码 bite  strong&gt; strong&gt; strong&gt; strong&gt; strong&gt; strong  “不要将所有鸡蛋都放在一个篮子里； 提醒我们，将不同类型的敏感数据（例如2FA恢复代码）分开很重要。使用 S4F3-C0D3S ，您可以将此信息存储在专用的加密保险库中，从而降低了一次损害多个安全层的风险。     &lt;！ -  sc_on-&gt;＆&gt; 32;提交由＆＃32; /u/u/fajremvp      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kkfy14/s4f3c0d3s_recovery_codes_manager/</guid>
      <pubDate>Mon, 12 May 2025 00:50:02 GMT</pubDate>
    </item>
    <item>
      <title>从工程师到领导角色成长时的7个常见错误</title>
      <link>https://www.reddit.com/r/programming/comments/1kkao8a/7_common_mistakes_when_growing_from_engineer_to_a/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/gregorojstersek      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kkao8a/7_common_mistakes_when_growing_from_engineer_to_a/</guid>
      <pubDate>Sun, 11 May 2025 20:35:06 GMT</pubDate>
    </item>
    <item>
      <title>如何使用AI成为出色的工程领导者</title>
      <link>https://www.reddit.com/r/programming/comments/1kkan4l/how_to_use_ai_to_be_a_great_engineering_leader/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/u/u/gregorojstersek     ＆＃32;   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kkan4l/how_to_use_ai_to_be_a_great_engineering_leader/</guid>
      <pubDate>Sun, 11 May 2025 20:33:43 GMT</pubDate>
    </item>
    <item>
      <title>XKCD的“值得花时间吗？”被认为有害</title>
      <link>https://www.reddit.com/r/programming/comments/1kk9u45/xkcds_is_it_worth_the_time_considered_harmful/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/agumonkey       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk9u45/xkcds_is_it_worth_the_time_considered_harmful/</guid>
      <pubDate>Sun, 11 May 2025 19:58:58 GMT</pubDate>
    </item>
    <item>
      <title>如何轻松测量python脚本的每行需要多长时间运行？</title>
      <link>https://www.reddit.com/r/programming/comments/1kk9u31/how_to_easily_measure_how_long_each_line_of_a/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  嗨，我所有我已经建立了这个项目 lblprof 能够非常迅速地概述我的python python python pyto pyem pyem pyem py     pep669     我的项目做什么？ 目标是能够很快地知道在我的代码执行过程中，在我的代码执行过程中，每一个级别的时间都在            precip.    precip.  i，真的很在乎很容易花了100毫秒。我构建了这个项目，以替换我正在滥用的旧良好 print（start -time.time（））。 此软件包配置文件并在终端中显示一棵树（显示每行的持续时间） href =“ https://raw.githubusercontent.com/le-codeur-rapide/lblprof/refs/heads/main/main/docs/terminalui_showcase.png”&gt; terminalui_showcase.png（1210×523）他们的代码的执行时间是分发的。 （最长的行是什么？并发有效吗？以下哪些导入需要太多时间？...） 安装    pip install lblprof    此软件包的唯一依赖性是pydantic的，其余是标准库。 functions:  start_tracing(): Start the tracing of the code. stop_tracing(): Stop the tracing of the code, build the tree and compute stats show_interactive_tree(min_time_s: float = 0.1): show the终端中的交互式持续时间树。   show_tree（）：将树打印到控制台。             来自lblprof import intim stop_tracing（）show_tree（）＃＃将树打印到控制台show_interactive_tree（）＃在终端中显示互动树   交互式终端基于库中  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/usemopherwrong6851       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk9u31/how_to_easily_measure_how_long_each_line_of_a/</guid>
      <pubDate>Sun, 11 May 2025 19:58:55 GMT</pubDate>
    </item>
    <item>
      <title>Starguard  - 发现伪造GitHub星星，危险依赖和许可陷阱的CLI</title>
      <link>https://www.reddit.com/r/programming/comments/1kk9fy6/starguard_cli_that_spots_fake_github_stars_risky/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  当我遇到一项跟踪 450万个假github星星的研究证实，我证实了我对一段时间的努力：noisy noisy noisy。 The issue is they’re visible, they’re persuasive, and they still shape hiring decisions, VC term sheets, and dependency choices—but they say very little about actual quality. I wrote StarGuard to put that number in perspective based on my own methodology inspired with what they did and to fold a broader supply-chain check into one command-line run. It starts with the simplest raw input: every  Starred_at  Timestamp Github将提供。它采用中位数排除测试来定位突然的爆发。对于每个尖峰，Starguard都会随机抽取其背后的帐户样本，并问：用户几岁？有追随者吗？有贡献历史吗？仍在使用默认的头像吗？由此，它计算出一个假星指数，在0（有机）和1（完全合成）之间。 ，但膨胀的恒星只是一个问题。同时，Starguard Parses依赖性表现出来或SBOMS和标志常见的风险标志：未添加版本，直接的GIT URL，loughike套件的包装名称。它还扫描许可证 -  AGPL潜入声称MIT的存储库，或其他可能会变成合规性头痛的不一致之处。 它也检查了贡献者模式。如果90％的提交来自一个几个月没有推动的人，那就标记了。它浏览了明显的代码危险信号：评估呼叫，缩小斑点，粗略的安装脚本 - 因为有时问题隐藏在明显的视线中。 所有这些都将其输入加权评分模型。最终的信任得分（0-100）一目了然地反映了回购健康，对假星行为的直接处罚，因此，一个漂亮的识别徽章无法掩盖无机的炒作。 我为此而添加了它为它带来了一个很酷的小徽章，为它带来了一个很酷的小徽章。在任何公共回购上运行以下方式以：   python starguard.py所有者/repo -format markdown    它可以没有令牌工作，但是您会尽快点击率限制。  repo is：存储库    这也是研究的存储库，并让人们表现出一些爱。        请提供任何您可以的反馈。 我主要对未来的两件事感兴趣：  当您尝试在您已经知道的存储库上，假星索引是否会感到准确？ 实际上还有哪些其他质量信号是什么其他有用的信号？打开问题比率？社区响应？   &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/welecomemysterious122       [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk9fy6/starguard_cli_that_spots_fake_github_stars_risky/</guid>
      <pubDate>Sun, 11 May 2025 19:41:46 GMT</pubDate>
    </item>
    <item>
      <title>Colibri和干净的建筑 -  Swift中的声明性编码</title>
      <link>https://www.reddit.com/r/programming/comments/1kk8zph/colibri_and_clean_architecture_declarative_coding/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/vikingosegundo    href =“ https://decodemeester.medium.com/colibri-and-clean-architecture-declarative-coding-coding-in-swift-c4246ccf9f21”&gt; [link]   ＆＃32;   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk8zph/colibri_and_clean_architecture_declarative_coding/</guid>
      <pubDate>Sun, 11 May 2025 19:22:08 GMT</pubDate>
    </item>
    <item>
      <title>Netflix建立在Java上</title>
      <link>https://www.reddit.com/r/programming/comments/1kk88p8/netflix_is_built_on_java/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  这是Netflix如何构建Java以及他们如何与Spring Boot团队合作以构建自定义内容的摘要。  对于想要观看Netflix团队的完整视频的人：  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/stealth_master01      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk88p8/netflix_is_built_on_java/</guid>
      <pubDate>Sun, 11 May 2025 18:49:55 GMT</pubDate>
    </item>
    <item>
      <title>Unison Cloud上的微服务：静态键入，动态部署•Runar Bjarnason</title>
      <link>https://www.reddit.com/r/programming/comments/1kk5wap/microservices_on_unison_cloud_statically_typed/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/goto-con       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk5wap/microservices_on_unison_cloud_statically_typed/</guid>
      <pubDate>Sun, 11 May 2025 17:08:28 GMT</pubDate>
    </item>
    <item>
      <title>编程神话我们迫切需要退休</title>
      <link>https://www.reddit.com/r/programming/comments/1kk5j0m/programming_myths_we_desperately_need_to_retire/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/waozen      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk5j0m/programming_myths_we_desperately_need_to_retire/</guid>
      <pubDate>Sun, 11 May 2025 16:52:28 GMT</pubDate>
    </item>
    <item>
      <title>由python启发的Rust API，由Serde提供支持</title>
      <link>https://www.reddit.com/r/programming/comments/1kk5bz4/a_rust_api_inspired_by_python_powered_by_serde/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/u/foxintheredbox      [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk5bz4/a_rust_api_inspired_by_python_powered_by_serde/</guid>
      <pubDate>Sun, 11 May 2025 16:43:51 GMT</pubDate>
    </item>
    <item>
      <title>MIDA：对于那些勇敢的灵魂仍在2025年仍在写C</title>
      <link>https://www.reddit.com/r/programming/comments/1kk47gl/mida_for_those_brave_souls_still_writing_c_in/</link>
      <description><![CDATA[&lt;！ -  sc_off-&gt;  对于那些仍在记忆安全的语言时代（我和你在一起）的人，我想分享一个我制作的小图书馆，这些库有助于C解决一个最令人讨厌的怪癖之一 - 完全缺乏阵列元数据。 Augmentation）是一个仅小型标头的C库，它将元数据附加到您的阵列和结构上，因此您实际上可以知道它们的大小而无需手动跟踪此信息。我知道革命性的概念。 为什么有人会这样做？ ，因为有时您卡住了维护旧版C代码。或在嵌入式系统上工作。或者，您只是喜欢偶尔的Segfault，以使您保持谦虚。 Whatever your reasons for using C in 2024, MIDA tries to make one specific aspect less painful. If you&#39;ve ever written code like this: c void process_data(int *data, size_t data_length) { // pray that the caller remembered the right length for (size_t i = 0; i &lt; data_length; i++) { // do stuff } }  并希望您可以做： c void process_data（int *data）{size_t data_length = mida_length（data）; // ✨ magic ✨ for (size_t i = 0; i &lt; data_length; i++) { // do stuff without 27 redundant size parameters } }  Then this might be for you! How it works In true C fashion, it&#39;s all just pointer arithmetic and memory trickery. MIDA attaches a small metadata header before your actual data, so your pointers work exactly like normal C arrays: ```c // For the brave C99 users int *numbers = mida_array(int, { 1, 2, 3, 4, 5 }); // For C89 holdouts (respect for maintaining 35-year-old code) int data[] = {1, 2, 3、4、5}; MIDA_BYTEMAP（bytemap，sizeof（data））; int *包装= mida_wrap（数据，bytemap）; ```` 但是，等等，还有更多！ 您甚至可以添加自己的自定义元数据字段： ``c // c //定义自己的元数据结构packet_metadata {uint16_t packet_id; //您自己的字段uint32_t crc; uint8_t标志; MIDA_EXT_METADATA; //标准元数据字段是最后一个};   //现在每个阵列都可以随身携带您的自定义信息uint8_t *packet = mida_ext_malloc（struct packet_metadata，sizeof（uint8_t），128），128），     // packet_metadata，数据包）; meta-＆gt; packet_id = 0x1234; meta-＆gt; flags = flag_urgent | flag_encrypted; ```` &#39;但是我在一个嵌入式平台上，不能使用malloc！＆quot&#39; 没问题！ MIDA可与堆栈分配的内存（或任何预先分配的缓冲区）： ```````c //带有元数据Uint8_t uint8_t Raw_buffer [64]; MIDA_BYTEMAP（bytemap，sizeof（raw_buffer））; uint8_t *buffer = mida_wrap（raw_buffer，bytemap）;    //现在您可以假装像C具有适当的阵列printf（“缓冲长度：％zu” zu \ n＆quort&#39;＆quort&#39;＆quid&#39;mida_length（buffer（buffer））; ```` 这是个玩笑吗？ 仅部分！虽然我认识到C更优雅地解决这些问题的现代替代方案，但有时您只需要与C一起工作。   整个事情都在单个标头文件（〜600行）中，已获得MIT许可，并且可用： https://github.com/lcsmuller/mida     ，如果像我一样，您会发现自己喃喃自语“我希望C知道它的阵列有多大，第1000次，也许尝试一下。 ，或者您知道，使用Rust/Go/任何现代语言，并从内存安全的高度嘲笑我们C程序员。那也很好。  &lt;！ -  sc_on-&gt;＆＃32;提交由＆＃32; /u/u/lucasmull       [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk47gl/mida_for_those_brave_souls_still_writing_c_in/</guid>
      <pubDate>Sun, 11 May 2025 15:54:07 GMT</pubDate>
    </item>
    <item>
      <title>赢得克鲁德</title>
      <link>https://www.reddit.com/r/programming/comments/1kk44bo/winning_cluedo/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/knaapje      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk44bo/winning_cluedo/</guid>
      <pubDate>Sun, 11 May 2025 15:50:09 GMT</pubDate>
    </item>
    <item>
      <title>为什么没有人谈论有关可观察性跨信号的查询？</title>
      <link>https://www.reddit.com/r/programming/comments/1kk2ue8/why_no_one_talks_about_querying_across_signals_in/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/elizobserves     &lt;a href =“ https://www.reddit.com/r/programming/comments/1kk2ue8/why_no_no_one_talks_about_querying_across_signals_inal/]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk2ue8/why_no_one_talks_about_querying_across_signals_in/</guid>
      <pubDate>Sun, 11 May 2025 14:53:15 GMT</pubDate>
    </item>
    <item>
      <title>6502 SIEMENS PC 100组装手册中的非法开孔（1980）</title>
      <link>https://www.reddit.com/r/programming/comments/1kk1qiv/6502_illegal_opcodes_in_the_siemens_pc_100/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/namanyayg     [link]&gt; [link]   [注释]   ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk1qiv/6502_illegal_opcodes_in_the_siemens_pc_100/</guid>
      <pubDate>Sun, 11 May 2025 14:02:36 GMT</pubDate>
    </item>
    <item>
      <title>异步/等待在Python的工作</title>
      <link>https://www.reddit.com/r/programming/comments/1kk1qil/how_asyncawait_works_in_python/</link>
      <description><![CDATA[＆＃32;提交由＆＃32;态href =“ https://tenth千分之一：/blog/python-behind-the-scenes-scenes-12-how-asyncawait-works-in-python/”&gt; [link]   ＆＃32;   [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk1qil/how_asyncawait_works_in_python/</guid>
      <pubDate>Sun, 11 May 2025 14:02:36 GMT</pubDate>
    </item>
    <item>
      <title>WASM 2.0</title>
      <link>https://www.reddit.com/r/programming/comments/1kk1qhi/wasm_20/</link>
      <description><![CDATA[＆＃32;提交由＆＃32; /u/u/namanyayg      [注释]  ]]></description>
      <guid>https://www.reddit.com/r/programming/comments/1kk1qhi/wasm_20/</guid>
      <pubDate>Sun, 11 May 2025 14:02:34 GMT</pubDate>
    </item>
    </channel>
</rss>